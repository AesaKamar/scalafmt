80 columns                                                                     |
<<< Unindent singleline
case FormatToken(_: Ident | _: `this` | _: `_ ` | _: `(`, _: `.` | _: `#`, _) => List(
  NoSplit0
)
>>>
case FormatToken(
    _: Ident | _: `this` | _: `_ ` | _: `(`, _: `.` | _: `#`, _) =>
  List(NoSplit0)
<<< Long if
case tok if tok.left.name.startsWith("xml") && tok.right.name.startsWith("xml") => List( NoSplit0 )
>>>
case tok
    if tok.left.name.startsWith("xml") && tok.right.name.startsWith("xml") =>
  List(NoSplit0)
<<< Pathological if
case FormatToken(left, open: `(`, _)
    if owners(open).isInstanceOf[Term.Apply] ||
      owners(left).parent.exists(_.isInstanceOf[Defn.Def]) ||
      owners(left).parent.exists(_.isInstanceOf[Defn.Class]) =>
  List(
    NoSplit0
  )
>>>
case FormatToken(left, open: `(`, _)
    if owners(open).isInstanceOf[Term.Apply] ||
    owners(left).parent.exists(_.isInstanceOf[Defn.Def]) ||
    owners(left).parent.exists(_.isInstanceOf[Defn.Class]) =>
  List(NoSplit0)
<<< SKIP wrapped cond inside if
case Decision(t@FormatToken(comma: `,`, right, between), splits)
        if owners.get(open) == owners.get(comma) &&
        // If comment is bound to comma, see unit/Comment.
        (
          !right.isInstanceOf[Comment] ||
          between123.exists(_.isInstanceOf[`\n`])) =>
      Decision(t, splits.filter(_.modification == Newline))
>>>
case Decision(t@FormatToken(comma: `,`, right, between), splits)
    if owners.get(open) == owners.get(comma) &&
    // If comment is bound to comma, see unit/Comment.
    (!right.isInstanceOf[Comment] || between123.exists(_.isInstanceOf[`\n`])) =>
  Decision(t, splits.filter(_.modification == Newline))
