40 columns                              |
<<< one arg chained (state explosion)
a(b).c(d).e(f).g(h).i(j).k { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa }
>>>
a(b).c(d).e(f).g(h).i(j).k {
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
}
<<< avoid dead ends
function(
    firstCall(a, b, c, d, e, f, g, h),
    secondCall("very long argument string"));
>>>
function(
    firstCall(a, b, c, d, e, f, g, h),
    secondCall(
        "very long argument string"));
<<< Presentation
MyObject(config.getBoolean("shortKey"),
         config.getString("reallyReallyReallyLongKey"),
         liveAnalysis.check(options.has("live"),
                            options.has("analysis")))
>>>
MyObject(
    config.getBoolean("shortKey"),
    config.getString(
        "reallyReallyReallyLongKey"),
    liveAnalysis
      .check(options.has("live"),
             options.has("analysis")))
<<< optimalAt memoization is by split prefix
new Compiler(
    primitives.options.has("primitives"),
    minify.options.has("minify"),
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
>>>
new Compiler(
    primitives.options
      .has("primitives"),
    minify.options.has("minify"),
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
<<< Prune redundant branches
new Compiler(
    assertions.options.has("checked-mode"),
    annotations.options.has("annotations"),
    primitives.options.has("primitives"),
    minify.options.has("minify"),
    preserve.options.has("preserve"),
    liveAnalysis.check(options.has("live"), options.has("analysis")),
    multi.options.has("multi"),
    sourceMap.options.has("source-map"));
>>>
new Compiler(
    assertions.options
      .has("checked-mode"),
    annotations.options
      .has("annotations"),
    primitives.options
      .has("primitives"),
    minify.options.has("minify"),
    preserve.options.has("preserve"),
    liveAnalysis
      .check(options.has("live"),
             options.has("analysis")),
    multi.options.has("multi"),
    sourceMap.options
      .has("source-map"));
<<< SKIP comment after (
var list = List( // comment
  function(a: A, b: B, c: C)
)
>>>
var list = List( // comment
  function(a: A, b: B, c: C)
)
<<< long
var list = List(
  function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C), function(a: A, b: B, c: C)
);
>>>
var list = List(
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C),
    function(a: A, b: B, c: C));
<<< Single line with block {}
function(a, b, c, {
    case Foo("a", 1) => Foo("b", 2)
  })
>>>
function(a, b, c, {
      case Foo("a", 1) => Foo("b", 2)
    })
