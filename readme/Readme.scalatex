@import Main._
@import org.scalafmt.readme.Readme._
@import org.scalafmt.ScalafmtStyle

@sect("Scalafmt - code formatter for Scala", org.scalafmt.Versions.stable)

  @p
    @raw
      <a href="https://codecov.io/github/olafurpg/scalafmt?branch=master"><img src="https://camo.githubusercontent.com/75d300982e3330c6b8eaaba63adad94fecd71287/68747470733a2f2f636f6465636f762e696f2f6769746875622f6f6c6166757270672f7363616c61666d742f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="https://codecov.io/github/olafurpg/scalafmt/coverage.svg?branch=master" style="max-width:100%;"></a>
      <a href="https://travis-ci.org/olafurpg/scalafmt"><img src="https://camo.githubusercontent.com/6b6e23e24c648ccd29152db1fbee32bf88eccb46/68747470733a2f2f7472617669732d63692e6f72672f6f6c6166757270672f7363616c61666d742e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/olafurpg/scalafmt.svg?branch=master" style="max-width:100%;"></a>
      <a href="https://gitter.im/olafurpg/scalafmt?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/382ebf95f5b4df9275ac203229928db8c8fd5c50/68747470733a2f2f6261646765732e6769747465722e696d2f6f6c6166757270672f7363616c61666d742e737667" alt="Join the chat at https://gitter.im/olafurpg/scalafmt" data-canonical-src="https://badges.gitter.im/olafurpg/scalafmt.svg" style="max-width:100%;"></a>

  @blockquote
    Any style guide written in English is either so brief that itâ€™s ambiguous,
    or so long that no one reads it.

  @blockquote
    -- Bob Nystrom, @lnk("\"Hardest Program I've Ever Written\"", "http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/"),
    Dart, Google.

  @p
    @lnk("Scalafmt", repo) turns the mess on the left into the (hopefully)
    readable, idiomatic and consistently formatted Scala code on the right.

  @demo
    object FormatMe { List(number) match { case head :: Nil if head % 2 == 0 => "number is even"
      case head :: Nil => "number is not even"
      case Nil => "List is empty" }
      function(arg1, arg2(arg3(arg4, arg5, "arg6"), arg7 + arg8), arg9.select(1, 2, 3, 4, 5, 6)) }

  @p
    Scalafmt is quite new.
    Still, it already seems to be useful for some people so it might also be
    useful for you.
    Scalafmt can format almost all of Spark, Akka, Scala.js and the IntelliJ
    Scala plugin.
    It's quite fast, too.
    Over 95% of all files format in under under 160ms on my laptop and less
    than 1% of all files take more than 1 second.
    The default style should work great, but if you need more
    there are some handy @sect.ref{Configuration} options.

  @p
    Curious to learn more about scalafmt? Check out this talk:

  @raw
    <iframe src="https://player.vimeo.com/video/165929294" width="100%" style="height: 28em;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

  @sect{Installation}

    @sect{IntelliJ}
      @lnk("Here is the plugin", "https://plugins.jetbrains.com/plugin/8236?pr=").
      You can install it directly from within IntelliJ,
      @ul
        @li
          open @code("Settings > Plugins")
        @li
          open @code("Browse repositories")
        @li
          search for @code("scalafmt")
        @li
          restart IntelliJ.

      @p
        The default shortcut is @code("Ctrl + Shift + L").
        Undo works, but not redo.

      @p
        The plugin determines which style to use in this order:
        @ol
          @li
            @code(".scalafmt") in the project's root directory, if it exists
          @li
            @code("$HOME/.scalafmt"), if it exists
          @li
            Otherwise, uses @code("default") style.
        For details on how @code(".scalafmt") should look like, see
        @sect.ref{Configuration}.

    @sect{SBT}
      @hl.scala
        addSbtPlugin("com.geirsson" % "sbt-scalafmt" % "@org.scalafmt.Versions.stable")

      @ul
        @li
          @lnk("Here is an example repository using sbt plugin.",
               "https://github.com/olafurpg/sbt-scalafmt-example")
        @li
          Run @code("sbt scalafmt") to format all files in the project.
        @li
          Run @code("sbt scalafmtTest") to test whether all files are are
          properly formatted. An exception is thrown in case of failure, no
          files are formatted.
        @li
          Set @code("scalafmtConfig in ThisBuild := Some(file(\".scalafmt\"))")
          to let the plugin pick up custom style configurations from
          @code(".scalafmt") in the root directory of your project.
          For details, see @sect.ref{Configuration}.
        @li
          If you use @code("*.scala") build rules you may need to import
          @code("org.scalafmt.sbt.ScalaFmtPlugin.autoImport._").
        @li
          Add @code("reformatOnCompileSettings") to you build settings to
          enable automatically formatting files on compile.
          @b("WARNING"). This setting is very intrusive on text editors and IDEs.
          I encourage you to find a better way to incorporate scalafmt into your
          workflow.
        @li
          In case of any trouble, try to run @code("reload") and @code("clean").
        @li
          If you have a multi-project build and the custom @code(".scalafmt") configuration is
          not picked up, make sure that @code("scalafmtConfig") is defined for
          all of your projects, not only the root project.
          Use @code("show scalafmtConfig") to verify that
          @code("scalafmtConfig := Some(file(.scalafmt))")
          in all of your projects.

    @sect{CLI}
      There are several ways to install the CLI.

      @sect{Build from source}
        For the greatest performance and prettiest output.

        @ul
          @li
            Clone the @lnk("repo", repo).
          @li
            Run @code("sbt assembly"), master branch should pass tests.
          @li
            @code("cli/target/scala-2.11/scalafmt.jar") should exist.
          @li
            follow instructions in @sect.ref{scalafmt.jar}.


      @sect{scalafmt.jar}

        You can also download a pre-compiled jar from the
        @lnk("releases page", repo + "/releases").

        Next, create a script named @code("scalafmt") somewhere in your
        @code("PATH") with the command:

        @hl.scala
          java -jar PATH_TO/scalafmt.jar $@@


      @sect{Homebrew/Mac OSX}
        @hl.scala
          brew install olafurpg/scalafmt/scalafmt
          scalafmt --version // should be @org.scalafmt.Versions.stable

      @sect{Linux/Windows/...}

        Help wanted!

      @sect{Usage examples}

        Please refer to the @code("--help") page.
        @note. This help page is generated from the @code{master} branch and
        may include flags that have not been published yet.
        @hl.scala()

        @hl.scala(
          org.scalafmt.cli.Cli.buildInfo + "\n" +
          org.scalafmt.cli.Cli.parser.usage)

    @sect{Vim}
      @ul
        @li
          Make sure you have the @sect.ref{CLI} installed and working.
        @li
          install @lnk("vim-autoformat", "https://github.com/Chiel92/vim-autoformat")
        @li
          add to your @code(".vimrc")
          @hl.scala
            noremap <F5> :Autoformat<CR>
            let g:formatdef_scalafmt = "'scalafmt'"
            let g:formatters_scala = ['scalafmt']

      @note. You pay the JVM startup penalty on every format.

    @sect{Standalone library}
      Add to your dependencies
      @hl.scala
        libraryDependencies += "com.geirsson" %% "scalafmt" % "@org.scalafmt.Versions.stable"
      @p
        Use the API like this

      @repl
        org.scalafmt.Scalafmt.format("""
        object FormatMe { List(Split(Space, 0).withPolicy(SingleLineBlock(close)), Split(Newline, 1).withPolicy{ case Decision(t@@FormatToken(_, `close`, _), s) => Decision(t, List(Split(Newline, 0)))}.withIndent(2, close, Right)) }
         """).get

    @sect{Coming soon...}

      @ul
        @li
          Ensime
        @li
          Scala IDE (@lnk("help wanted!", "https://github.com/olafurpg/scalafmt/issues/125"))
        @li
          Your favorite editor? Join the gitter channel.

  @sect{Configuration}

    @p
      There are two ways to configure @code("scalafmt").

      @ol
        @li
          As Scala code via the @code("ScalafmtConfig") case class.
          This is handy when using scalafmt as a standalone library.
          For details, refer to the Scaladoc.
        @li
          In a plain text file, options are defined as CLI flags.
          I recommend you create a file named @code(".scalafmt") and keep it in
          the root directory of your project.

          @p
            Here is an example @code(".scalafmt").

            @cliFlags
              # Example .scalafmt, comments are supported.
              --style defaultWithAlign # For pretty alignment.
              --maxColumn 100          # For my wide 30" display.

            To experiment with different options, I recommend you use the CLI.
            For details, read about the @code("--config") flag in the
            @code("--help") page of the CLI.

      Here are examples of the most common configuration options.
      For a full list of available flags, consult the @code{--help} page of the
      CLI or the @lnk("ScalafmtStyle docstring", "https://github.com/olafurpg/scalafmt/blob/master/core/src/main/scala/org/scalafmt/ScalafmtStyle.scala").

    @sect{--style}
      Option 1: @b{default}
      @fmt(ScalafmtStyle.default.copy(maxColumn = 40))
        // Column 40                           |
        // non bin packed parent constructors
        object ScalaJsStyle extends Parent with SecondParent with ThirdParent {
          // non bin packed arguments
          function(argument1, argument2(argument3, argument4))
          // No vertical alignment
          x match {
            case 1 => 1
            case 11 => 1
          }
        }

      Option 2: @b{defaultWithAlign}
      @fmt(ScalafmtStyle.defaultWithAlign.copy(maxColumn = 40))
        // Column 40                           |
        object ScalaJsStyle extends Parent with SecondParent with ThirdParent {
          // vertical alignment
          x match {
            case 1 => 1 // align me
            case 11 => 11 // align me too

            case x => // blank line breaks alignment
          }
          for {
            x <- List(1)
            xx <- List(1, 2)
          } yield x * xx
          // A whole bunch of other
          // alignment goodies.
          // ...
        }

      Option 3: @b{Scala.js} (experimental)
      @fmt(ScalafmtStyle.scalaJs.copy(maxColumn = 40))
        // Column 40                           |
        // bin packed parent constructors
        object ScalaJsStyle extends Parent with SecondParent with ThirdParent {
          // bin packed arguments
          function(argument1, argument2, argument3, argument4)
          // Vertical alignment for only =>
          x match {
            case 1 => 1
            case 11 => 1
          }
        }

    @sect{--maxColumn}
      Default: @b{80}

      @ul
        @li
          Keep in mind that 80 characters fit perfectly on a split laptop screen
          with regular resolution.
        @li
          Github mobile view only shows 80 characters and sometimes you need
          to look at code on your phone.
        @li
          Consider refactoring your code instead of choosing a value over 100.

    @sect{--continuationIndentCallSite}
      Default: @b{4}

      @p
        Example:
        @hl.scala
          function(
              argument1 // indented by 4
          )

    @sect{--continuationIndentDefnSite}
      Default: @b{4}

      @p
        Same as @code{--continuationIndentCallSite} except for definition site.
        Example:
        @hl.scala
          def function(
              argument1: Type1 // indented by 4
          ): ReturnType

    @sect{--alignTokens}
      Default: @b{off}

      @p
        The style @code("defaultWithAlign") has pre-configured a variety of
        tokens that align together nicely.

        @exampleAlign
          // 40 columns                          |
          object TokenAlignment {
            x match {
              // Align by => and -> and //
              case 1 => 1 -> 2 // first
              case 11 => 11 -> 22 // second

              // A blank line separates alignment blocks.
              case `ignoreMe` => 111 -> 222
            }

            // Align assignments of similar type.
            def name = column[String]("name")
            def status = column[Int]("status")
            val x = 1
            val xx = 22

            // Align sbt module IDs.
            libraryDependencies ++= Seq(
              "org.scala-lang" % "scala-compiler" % scalaVersion.value,
            "com.lihaoyi" %% "sourcecode" % "0.1.1"
            )
          }

         If you need more customization, refer to the @code{--help}.

    @sect{// format: off}
      Disable formatting for specific regions of code by wrapping them in
      @code("// format: OFF") blocks:

      @example(org.scalafmt.util.FileOps.readFile("readme/matrix.example"))

      To disable formatting for a whole file, put the comment at the top of
      the file.

      @ul
        @li
          the comment string is case insensitive, you can also write
          @code("// format: OFF").
        @li
          The comments @code("// @formatter:off") and @code("// @formatter:off")
          will also work, for compatibility with the IntelliJ formatter.
        @li
          Scalafmt will do it's best to resume formatting at the correct
          indentation level. It's best to enable formatting at the same level as
          when it was disabled.

    @sect{--assumeStandardLibraryStripMargin}
      Default: @b{false}

      @p
        If @b{true}, the margin character @code("|") is aligned with the opening triple
        quote @code("\"\"\"") in interpolated and raw string literals.

        @example(org.scalafmt.util.FileOps.readFile("readme/stripMargin.example"),
                 stripMarginStyle)

        @note. May cause non-idempotent formatting in rare cases, see @issue(192).

  @sect{Formatting rules}
    @p
      @note. The rules are still evolving. Feel free to discuss about them in
      the gitter channel. To start with, I implemented a default style that I
      like myself.

    @p
      The plan is to later add support for few official coding styles that have
      proven to work for large codebases and scale to at least a few dozens
      of contributors. For example, from
      @lnk("Scala.js", "https://github.com/scala-js/scala-js/blob/master/CODINGSTYLE.md") and
      @lnk("Spark", "https://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide").

    @sect{Function application}

      @example
        // 40 columns                          |
        object FunctionApplication {
          // 1. Fits on a single line
          function(arg1, arg2, arg3)

          // 2. One line for each argument, indented at (
          function(longerArg1, longerArg2, longerArg3)

          // 3. One line for each argument, indented at 4
          function(superDuperLongArg(
              evenHasNestedArgs, notOnlyOneButTwo), // This arg is too long.
              arg2IsNotAsBad)

          // 4. (opt-in) "Config style", put newline after opening (
          // and newline before closing ) to force one argument
          // on each line indented by 4. Overrides other options.
          function(
              longerArg1 = defaultValue1, longerArg2 = defaultValue2, longerArg3 = defaultValue3
              ) // Closing ) gets a newline
        }

      These rules are re-used in the following contexts:
      @ul
        @li
          Curried functions. Rules are applied on each individual pair of
          parentheses independently from each other.
        @li
          Function declaration. No difference, default values
           are treated like named argument.
        @li
          Type application. Same rules, except for brackets @code("[]") instead
          of parentheses.

    @sect{Select chains}

      @example
        // 40 columns                          |
        object SelectChains {
          // 1. Fits on a single line
          List(1).map(_ + 1).filter(_ == 2)

          // 2. Force newline at each dot, with indent 2.
          List(1, 2, 3, 4)
            .map(_ + 1)
            .filter(_ % 2 == 0)
        }

    @sect{Pattern matching}

      @example
        // 40 columns                          |
        object PatternMatching {
          List(1, 2, 3) match {
            // if indented by 2, for separation from the case body.
            case 1 :: tail if tail.length == 2 => "1 is head"
            // if put on separate line, if condition doesn't fit on single line
            case lst if lst.length == 2 && lst.head == 1 => "lst has length 3"
          }
        }


  @sect{Known issues}
    @p
      @lnk("Developing code formatters is notoriously hard",
           "http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/")
      and scalafmt has been no exception.
      Scalafmt stopped being my full-time job after I handed in my thesis in June 2016.
      I will continue to work on scalafmt but you can expect the pace to slow down.
      The following are, in my opinion, the most critical issues with scalafmt
      that I can't guarantee when will be fixed:

      @sect{Non-idempotent}
        Scalafmt is non-idempotent for certain files. See @issue(339).
        This means you should be careful about enforcing scalafmt in your CI
        build.
        At v0.2.9, roughly 0.1% or 11 files out of ~9.400 source files in the
        test suite are affected by this issue.
        If sources are already formatted by scalafmt, only 1 file out of a sample
        of ~27.000 files triggers non-idempotent formatting.

      @sect{Deeply nested code}
        Scalafmt cannot yet format all files with deeply nested functions calls.
        Deeply nested code is troublesome because the number of possible
        formatting options grows exponentially with each new layer of nesting.
        Instead of taking seconds or minutes to complete formatting, scalafmt
        chooses to bail early and leave the source file unformatted.
        @p
          There are two workaround if you are affected by this issue:
          @ul
            @li
              Refactor your code to eliminate deeply nested function calls.
              Binding large function arguments to variables is a good start.
            @li
              Try the experimental @code{--bestEffortInDeeplyNestedCode} flag
              that will try to produce decent formatting output even for the most
              pathologically nested code. YMMV.
        @p
          Other cool code formatters like ClangFormat, dartfmt and rfmt use
          better techniques to solve this issue, which scalafmt can hopefully
          learn from.
          At v0.2.8, roughly 1% or 64 out of ~9.400 source files in the test suite
          are affected by this issue.

      @sect{Performance}
        Scalafmt is 6x slower than Scalariform.
        For 98% of source files this won't be a problem if you have a decently
        modern laptop.
        However, if you only work in files with 4.000 LOC it might be a problem.
        I'm quite sure that micro-optimizations can squeeze out at least ~2x
        performance improvements, maybe even more.
        Moreover, I think incremental formatting has the possibility to increase
        the performance by several orders of magnitude in interactive IDE
        environments where scalafmt is invoked on file save.


  @sect{FAQ / Troubleshooting}

     @sect{How can I be notified of releases/announcements?}
       Join @lnk("the scalafmt mailing list", "https://groups.google.com/forum/#!forum/scalafmt")
       to receive announcements of new releases only. No spam, promise.

     @sect{How do I customize scalafmt?}
       See @sect.ref{Configuration}.

     @sect{Why not Scalariform?}
       @lnk("Scalariform", "http://scala-ide.org/scalariform/") does an
       excellent job of tidying up common formatting errors. However,

       @ul
         @li
           Scalariform does not have a @code{--maxColumn} setting, which
           I personally like and is present in many popular coding styles.
         @li
           Scalariform preserves most line breaking decisions, leaving it up to
           you (or even worse, your colleagues) to choose a formatting layout.
           Scalafmt takes liberty to add/remove newlines, making your entire
           codebase look consistent.
         @li
           Scalariform cannot format
           @lnk("Dotty", "https://github.com/lampepfl/dotty"),
           which has minor syntactic differences to Scala, or SBT files which
           allow top-level statement. With scala.meta dialects, scalafmt will
           be able to format Dotty and SBT.

       Finally, scalafmt is my Master's thesis project. I thought it would
       be a fun challenge to write a code formatter :)

     @sect{Why is scalafmt so slow?}
       @p
         My benchmarks show that scalafmt is for most common cases around 4-6x
         slower than scalariform (btw, scalariform is already impressively fast).
         This means that formatting your average 1.000 LOC file on modern
         hardware will take around 200ms, which should still feel close enough
         to instant.

       @p
         The main feature that makes scalafmt slower than scalariform is the
         column-width limit.
         To figure the "best" way to break a long line, Scalafmt may try
         thousands of different formatting solutions.

       @p
         Performance is still a work in progress and will hopefully
         continue to improve in future releases. Help here is appreciated.

     @sect{Code formatters create unnecessary diffs!}
       That's not a question, but I agree that code formatters like scalafmt do
       sometimes increase the size of diffs in code reviews.
       I still believe it's worth it, considering

       @ol
         @li
           Proper formatting @lnk("helps you catch bugs", "https://twitter.com/extempore2/status/717716747181096960")!
         @li
           you can enable non-whitespace diffs during code review. For Github,
           add @code("?w=1") to the URL to ignore whitespace changes.
         @li
           @code{git blame} has a @code{-w} flag to ignore whitespace changes
           so you can still blame your colleagues if you reformat your codebase.
         @li
           code is read waaay more often outside of code reviews, for example
           when you are actually coding.

     @sect{Is the formatting output stable between releases?}
       No, the formatting rules will evolve even between PATCH releases.
       I recommend you add a commit formatting your whole project for every time
       scalafmt update.

  @scalatex.Changelog()

@raw
  <a href="https://github.com/olafurpg/scalafmt"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
  <!-- Stats -->
  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.olafurpg.github.io/scalafmt"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.lassie.io/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 3]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.lassie.io/hello/hello.php?idsite=3" style="border:0;" alt="" /></p></noscript>
  <!-- End Stats Code -->
