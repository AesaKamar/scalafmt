@import Main._

@def note = b("NOTE")

@def repo: String = "https://github.com/olafurpg/scalafmt"

@def half(frags: Frag*) = div(frags, width:="50%", float.left)

@def pairs(frags: Frag*) = div(frags, div(clear:="both"))

@def demo(code: String) = {
  import org.scalafmt._
  val formatted = ScalaFmt.format(code, ScalaStyle.UnitTest40)
  pairs(List(code, formatted).map(x => half(hl.scala(x))):_*)
}

@def example(code: String) = {
  import org.scalafmt._
  val formatted = ScalaFmt.format(code, ScalaStyle.Default40)
  hl.scala(formatted)
}

@sect("Scalafmt", org.scalafmt.Versions.latestPublished)
  @h1
    Opinionated code formatter for Scala

  @blockquote
    Any style guide written in English is either so brief that itâ€™s ambiguous,
    or so long that no one reads it.

  @blockquote
    -- Bob Nystrom, @lnk("\"Hardest Program I've Ever Written\"", "http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/"),
    Dart, Google.

  @p
    @lnk("Scalafmt", repo) turns the mess on the left into the (hopefully)
    readable, idiomatic and consistent Scala code on the right.

  @demo
    object FormatMe { List(number) match { case head :: Nil if head % 2 == 0 => "number is even"
      case head :: Nil => "number is not even"
      case Nil => "List is empty" }
      function(arg1, arg2(arg3(arg4, arg5, "arg6"), arg7 + arg8), arg9.select(1, 2, 3, 4, 5, 6)) }

  @p
    @lnk("Scalafmt", repo) is an opinionated code formatter.
    It means most of the time you can relieve your attention from carefully
    manipulating whitespace and focus instead on writing correct,
    maintainable code. Mark the end of dreadful arguments on formatting!

  @p
    @img(marginLeft := "auto", marginRight := "auto", display := "block", src := "https://cloud.githubusercontent.com/assets/1408093/12928034/99d3ffe8-cf6b-11e5-9ec5-42de7c4e0155.gif")

    @p
      Scalafmt is very new.
      Still, scalafmt is already useful for me so it might also be useful for you.
      Scalafmt is also mature enough to format all 920 files in the Scala.js
      repo. It's quite fast, too. Over 75% of the Scala.js files format in
      under 200ms.

    @p
      Don't hesitate to join the
      @lnk("gitter channel", "https://gitter.im/olafurpg/scalafmt")
      or post an @lnk("issue", repo + "/issues") in case of problems.


  @sect{Installation}

    @sect{SBT}
      @hl.scala
        addSbtPlugin("com.geirsson" %% "sbt-scalafmt" % "@org.scalafmt.Versions.latestPublished")

      @ul
        @li
          Run @code("sbt scalafmtFormat") to format all files in the project.
        @li
          Add @code("reformatOnCompileSettings") to you build settings to
          enable automatically formatting files on compile.
          @b("WARNING"). Formatting a large file (~4.000 LOC) can take up
          to 1-2s, so it might be undesirable to let scalafmt delay compilation.
          Computer generated code with deeply nested applications may take even
          longer to format or it might not even complete!

    @sect{IntelliJ}
      @lnk("Here is the plugin", "https://plugins.jetbrains.com/plugin/8236?pr=").
      You can install it directly from within IntelliJ,
      @ul
        @li
          open @code("Settings > Plugins")
        @li
          open @code("Browse repositories")
        @li
          search for @code("scalafmt")
        @li
          restart IntelliJ.

      @p
        The default shortcut is @code("Ctrl + Shift + L").
        Undo works, but not redo.

    @sect{CLI}
      There are several ways to install the CLI.

      @sect{Build from source}
        For the greatest performance and prettiest output.

        @ul
          @li
            Clone the @lnk("repo", repo).
          @li
            Run @code("sbt assembly"), master branch should pass tests.
          @li
            @code("cli/target/scala-2.11/scalafmt.jar") should exist.
          @li
            follow instructions in @sect.ref{scalafmt.jar}.


      @sect{scalafmt.jar}

        You can also download a pre-compiled jar from the
        @lnk("releases page", repo + "/releases").

        Next, create a script named @code("scalafmt") somewhere in your
        @code("PATH") with the command:

        @hl.scala
          java -jar PATH_TO/scalafmt.jar $@@


      @sect{Homebrew/OSX}
        @hl.scala
          brew tap olafurpg/scalafmt
          brew install scalafmt
          scalafmt --version // should be @org.scalafmt.Versions.scalafmt

      @sect{Usage examples}

        Once correctly installed, use the CLI like this.

        @hl.scala(org.scalafmt.cli.Cli.usageExamples)

    @sect{Vim}
      @ul
        @li
          Make sure you have the @sect.ref{CLI} installed and working.
        @li
          install @lnk("vim-autoformat", "https://github.com/Chiel92/vim-autoformat")
        @li
          add to your @code(".vimrc")
          @hl.scala
            noremap <F5> :Autoformat<CR>
            let g:formatdef_scalafmt = "'scalafmt'"
            let g:formatters_scala = ['scalafmt']

      @note. You pay the JVM startup penalty on every format.

    @sect{Standalone library}
      Add to your dependencies
      @hl.scala
        libraryDependencies += "com.geirsson" %% "scalafmt" % "@org.scalafmt.Versions.latestPublished"
      @p
        Use the API like this
        @hl.ref(wd/'readme/"library-usage.example")

    @sect{Coming soon...}

      @ul
        @li
          Ensime
        @li
          Scala IDE
        @li
          Your favorite editor? Join the gitter channel.

   @sect{Code examples}

     The following examples show which rules scalafmt uses to format your
     code. All examples use a 40 column limit.

     @p
       @note. The plan is to add support for few official coding styles that have
       proven to work for large codebases and scale to at least a few dozens
       of contributors. For example, the
       @lnk("Scala.js", "https://github.com/scala-js/scala-js/blob/master/CODINGSTYLE.md") and
       @lnk("Spark", "https://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide")
       coding styles.

     @p
       To start with, I implemented a default style for myself. The
       rules are still evolving. Feel free to discuss about them
       in the gitter channel.

     @sect{Function application}

       @example
         // 40 columns                          |
         object FunctionApplication {
           // 1. Fits on a single line
           function(arg1, arg2, arg3)

           // 2. Fits on a single line, with newline indented by 4
           function(longerArg1, longerArg2, arg3)

           // 3. One line for each argument, indented at (
           function(longerArg1, longerArg2, longerArg3)

           // 4. One line for each argument, indented at 4
           function(superDuperLongArg(
               evenHasNestedArgs, notOnlyOneButTwo), // This arg is too long.
               arg2IsNotAsBad)

           // 5. (opt-in) "Config style", put newline after opening (
           // and newline before closing ) to force one argument
           // on each line indented by 4. Overrides other options.
           function(
               longerArg1 = defaultValue1, longerArg2 = defaultValue2, longerArg3 = defaultValue3
               ) // Closing ) gets a newline
         }

       These rules are re-used in the following contexts:
       @ul
         @li
           Curried functions. Rules are applied on each individual pair of
           parentheses independently from each other.
         @li
           Function declaration. No difference, default values
            are treated like named argument.
         @li
           Type application. Same rules, except for brackets @code("[]") instead
           of parentheses.

     @sect{Select chains}

       @example
         // 40 columns                          |
         object SelectChains {
           // 1. Fits on a single line
           List(1).map(_ + 1).filter(_ == 2)

           // 2. Force newline at each dot, with indent 2.
           List(1, 2, 3, 4)
             .map(_ + 1)
             .filter(_ % 2 == 0)
         }

     @sect{Pattern matching}

       @example
         // 40 columns                          |
         object PatternMatching {
           List(1, 2, 3) match {
             // if indented by 2, for separation from the case body.
             case 1 :: tail if tail.length == 2 => "1 is head"
             // if put on separate line, if condition doesn't fit on single line
             case lst if lst.length == 2 && lst.head == 1 => "lst has lenght 3"
           }
         }

     @sect{stripMargin alignment}
       The margin character @code("|") is aligned with the opening triple
       quote @code("\"\"\"") in interpolated and raw string literals.

       @example(org.scalafmt.util.FilesUtil.readFile("readme/stripMargin.example"))

     @sect{// format: off}
       Disable formatting for specific regions of code by wrapping them in
       @code("// format: OFF") blocks:

       @example(org.scalafmt.util.FilesUtil.readFile("readme/matrix.example"))

       To disable formatting for a whole file, put the first comment
       at the top of the file.

       @ul
         @li
           the comment string is not case sensitive, so you can also write
           @code("// format: OFF").
         @li
           The comments @code("// @formatter:off") and @code("// @formatter:off")
           will also work, for compatibility with the IntelliJ formatter.
         @li
           Scalafmt will do it's best to resume formatting at the correct
           indentation level. It's best to enable it at the same level as
           when it was disabled.


   @sect{FAQ}

      @sect{Why not Scalariform?}
        @lnk("Scalariform", "http://scala-ide.org/scalariform/") does an
        excellent job of tidying up common formatting errors. However,

        @ul
          @li
            Scalariform does not support enforcing column-width limits, which
            I personally like and is present in many popular coding styles.
          @li
            Scalariform gives too much freedom on how you format your code, which
            makes it easy to write sloppy looking code after a few rounds of
            refactoring.
          @li
            Scalariform cannot format @lnk("Dotty", "https://github.com/lampepfl/dotty") code,
            which has minor syntactic differences to Scala. Being built with scala.meta,
            scalafmt can format dotty.
          @li
            The original Scalariform author stopped maintaining the library a
            few years ago.

        Finally, scalafmt is my Master's thesis project. I thought it would
        be a fun challenge to write a code formatter :)

     @sect{The formatter creates unnecessary diffs!}
       I understand that some rules may trigger unnecessarily large diffs in pull
       requests. I still believe it's worth it, considering

       @ol
         @li
           you can enable non-whitespace diffs during code review. For Github,
           add @code("?w=1") to the URL and the diff ignores whitespace changes.
         @li
           code is read more often outside of pull requests.

      @sect{Why is it so slow?}
        My benchmarks show that scalafmt is around 4-6x slower than scalariform.
        The main feature that makes scalafmt slower than scalariform is the
        column-width limit.
        To figure the "best" way to break a long line, Scalafmt sometimes tries
        thousands of different formatting solutions.

        @p
          The hope is that further optimizations will make scalafmt at
          least 2-3x faster than it is now.

      @sect{Is the formatting output stable between releases?}
        No, you can expect the formatting output to evolve with new releases.
        It's only at @org.scalafmt.Versions.latestPublished, after all.

      @sect{How do I customize scalafmt?}
        There is only one supported style at the moment: @code("ScalaStyle.Default").
        More settings will come later.

   @sect{Changelog}

     @sect{0.1.4}
       @ul
         @li
           @sect.ref{stripMargin alignment}.
         @li
           @sect.ref{// format: off}.
         @li
           @sect.ref{Select chains}.
         @li
           @lnk("Hanging behavior", "https://github.com/olafurpg/scalafmt/issues/127").
         @li
           @lnk("Dozens of other small fixes", "https://github.com/olafurpg/scalafmt/pull/128").

     @sect{0.1.3}
       @ul
         @li
           @lnk("Better handling of type parameters", "https://github.com/olafurpg/scalafmt/issues/117").
           Try it on your @lnk("craziest type signatures", "https://github.com/olafurpg/scalafmt/blob/6c4e5165bcbfa3a932cc112d7e87a1e919fcaf99/core/src/test/resources/default/DefDef.stat#L63").
         @li
           @lnk("Array assignments are treated like regular call-site applications", "https://github.com/olafurpg/scalafmt/issues/122").
         @li
           Commented out code remains un-indented (lines that start with
           @code("//") stay at indentation 0).
         @li
           Blank lines are only forced before top-level definitions and methods
           with docstrings.

     @sect{0.1.2}

       @ul
         @li
           Closed @lnk("17 formatting issues", "https://github.com/olafurpg/scalafmt/issues?utf8=%E2%9C%93&q=author%3Asjrd+created%3A%3C2016-03-10").
           Thank you Sebastian!
         @li
           Added Java 6+7 compatibility, was Java 8 before.

     @sect{0.1.1}
       @ul
         @li
           The @code("-f") flag in the CLI can be a directory.

     @sect{0.1.0}
       First release.

@raw
  <a href="https://github.com/olafurpg/scalafmt"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
  <!-- Stats -->
  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.olafurpg.github.io/scalafmt"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.lassie.io/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 3]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.lassie.io/hello/hello.php?idsite=3" style="border:0;" alt="" /></p></noscript>
  <!-- End Stats Code -->
