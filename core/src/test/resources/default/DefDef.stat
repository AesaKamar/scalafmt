80 columns                                                                     |
<<< Long line
object a {
  /**
    * Returns True is this state will always return better formatting than other.
    */
  def alwaysBetter(other: State): Boolean = this.cost <= other.cost &&
  this.indentation <= other.indentation
}
>>>
object a {

  /**
    * Returns True is this state will always return better formatting than other.
    */
  def alwaysBetter(other: State): Boolean =
    this.cost <= other.cost && this.indentation <= other.indentation
}
<<< context bound
def addDefn[T <: Keyword: ClassTag](mods: Seq[Mod], tree: Tree): Unit
>>>
def addDefn[T <: Keyword : ClassTag](mods: Seq[Mod], tree: Tree): Unit
<<< crazy signature
private def withNewLocalDefs(bindings: List[Binding]) (buildInner:(List[
        LocalDef],
    PreTransCont) => TailRec[Tree]) (cont: PreTransCont): TailRec[Tree]
>>>
private def withNewLocalDefs(bindings: List[Binding])(
    buildInner: (List[LocalDef], PreTransCont) => TailRec[Tree])(
    cont: PreTransCont): TailRec[Tree]
<<< SKIP function17
implicit def fromFunction17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
    T13, T14, T15, T16, T17, R](f: scala.Function17[T1, T2, T3, T4, T5, T6, T7,
    T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R]): Function17[T1, T2,
    T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17,
    R] = identity((x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7,
    x8: T8, x9: T9, x10: T10, x11: T11, x12: T12, x13: T13, x14: T14, x15: T15,
    x16: T16, x17: T17) => f(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11,
    x12, x13, x14, x15, x16, x17))
>>>
x
<<< SKIP insane type apply from u/refriedi via reddit
def myMethod[F[_]:Functor, G[_]:Applicative, A:DecodeJson:TypeTag:Meta, B:DecodeJson:TypeTag:Meta, C:Meta:TypeTag:UrlParameterEncode](gfa: G[F[A]], b: B)(f: (A,B) => C): Foo[C]
>>>
x
<<< SKIP type apply formats too #117
val x:FooBarrrrrr[BaaaaaaaaaaaazBazzz[String, Option[List[Either[Int, Option[String]]]]]]
>>>
x
