80 columns                                                                     |
<<< resolveLocalDef
    def withDedicatedVar: Unit = {
      def doBuildInner = {
        buildInner({ tinner =>
            tinner match {
              case _ =>
                rhsSideEfs match {
                  case _ =>  cont(PbreTransBlock(rhsSideEffects :: Nil, tinner))
                }
              }
        })
      }
    }
>>>
def withDedicatedVar: Unit = {
  def doBuildInner = {
    buildInner({ tinner =>
      tinner match {
        case _ =>
          rhsSideEfs match {
            case _ => cont(PbreTransBlock(rhsSideEffects :: Nil, tinner))
          }
      }
    })
  }
}
<<< missing 2 indent #209
{{ {
 preloads.foreach{p =>
      cache.getOrElseUpdate(p,
        futureStreams.map{r => r.streams.get(p)})
    }
    }}}
>>>
{
  {
    {
      preloads.foreach { p =>
        cache.getOrElseUpdate(p, futureStreams.map { r =>
          r.streams.get(p)
        })
      }
    }
  }
}
<<< nested lambdas #195
(excty, { focus: Focus =>
      val enter = symopt.map { sym =>
        val cast = focus withOp Op.As(excty, exc.value)
        curEnv.enter(sym, cast.value)
        cast
      }.getOrElse(focus)
      val begin = enter withOp Nrt.call(Nrt.begin_catch, excwrap.value)
      val res   = genExpr(body, begin)
      val end   = res withOp Nrt.call(Nrt.end_catch)
      end withValue res.value
    })
>>>
(excty, { focus: Focus =>
  val enter = symopt.map { sym =>
    val cast = focus withOp Op.As(excty, exc.value)
    curEnv.enter(sym, cast.value)
    cast
  }.getOrElse(focus)
  val begin = enter withOp Nrt.call(Nrt.begin_catch, excwrap.value)
  val res = genExpr(body, begin)
  val end = res withOp Nrt.call(Nrt.end_catch)
  end withValue res.value
})
<<< ONLY intellij bug

/**
 * This type means type projection:
 * SomeType#member
 * member can be class or type alias
 */
class ScProjectionType private (val projected: ScType, val element: PsiNamedElement,
                            val superReference: Boolean /* todo: find a way to remove it*/) extends ValueType {
  def copy(superReference: Boolean): ScProjectionType = new ScProjectionType(projected, element, superReference)

  override protected def isAliasTypeInner: Option[AliasType] = {
    if (actualElement.isInstanceOf[ScTypeAlias]) {
      actualElement match {
        case ta: ScTypeAlias => //higher kind case
          val args: ArrayBuffer[ScExistentialArgument] = new ArrayBuffer[ScExistentialArgument]()
          val genericSubst = ScalaPsiUtil.
            typesCallSubstitutor(ta.typeParameters.map(tp => (tp.name, ScalaPsiUtil.getPsiElementId(tp))),
            ta.typeParameters.map(tp => {
              val name = tp.name + "$$"
              args += new ScExistentialArgument(name, Nil, types.Nothing, types.Any)
              ScTypeVariable(name)
            }))
          val s = actualSubst.followed(genericSubst)
          Some(AliasType(ta, ta.lowerBound.map(scType => ScExistentialType(s.subst(scType), args.toList)),
            ta.upperBound.map(scType => ScExistentialType(s.subst(scType), args.toList))))
        case _ => None
      }
    }
  }
  }

>>>
x
