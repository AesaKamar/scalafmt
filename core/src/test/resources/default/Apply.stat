80 columns                                                                     |
<<< Massive 1
List(Split(Space, 0).withPolicy(SingleLineBlock(close)),
           Split(nl, 1).withPolicy({
             case Decision(t@FormatToken(_, `close`, _), s) =>
               Decision(t, List(Split(Newline, 0)))
           }).withIndent(2, close, Right))
>>>
List(Split(Space, 0).withPolicy(SingleLineBlock(close)),
     Split(nl, 1)
       .withPolicy({
         case Decision(t@FormatToken(_, `close`, _), s) =>
           Decision(t, List(Split(Newline, 0)))
       })
       .withIndent(2, close, Right))
<<< Massive 2
 List(Split(Space,
            0,
            policy = SingleLineBlock(close),
            ignoreIf = blockSize > style.maxColumn),
      Split(nl,
            1,
            policy = {
            case Decision(t@FormatToken(_, `close`, _), s) =>
            Decision(t, List(Split(Newline, 0)))
            }))
>>>
List(Split(Space,
           0,
           policy = SingleLineBlock(close),
           ignoreIf = blockSize > style.maxColumn),
     Split(nl, 1, policy = {
       case Decision(t@FormatToken(_, `close`, _), s) =>
         Decision(t, List(Split(Newline, 0)))
     }))
<<< Massive (good API) 3
Split(Space, 0).withPolicy {
    // Following case:
    // package foo // this is cool
    //
    // object a
    case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
        if !between.exists(_.isInstanceOf[`\n`]) =>
      Decision(t, splits.map(_.withModification(Space)))
    case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
      Decision(t, splits.map(_.withModification(Newline2x)))
}
>>>
Split(Space, 0).withPolicy {
  // Following case:
  // package foo // this is cool
  //
  // object a
  case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
      if !between.exists(_.isInstanceOf[`\n`]) =>
    Decision(t, splits.map(_.withModification(Space)))
  case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
    Decision(t, splits.map(_.withModification(Newline2x)))
}
<<< Massive (bad API) 3
Split(Space, 0, policy = {
    // Following case:
    // package foo // this is cool
    //
    // object a
    case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
        if !between.exists(_.isInstanceOf[`\n`]) =>
      Decision(t, splits.map(_.withModification(Space)))
    case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
      Decision(t, splits.map(_.withModification(Newline2x)))
})
>>>
Split(Space, 0, policy = {
  // Following case:
  // package foo // this is cool
  //
  // object a
  case Decision(t@FormatToken(`lastRef`, _: Comment, between), splits)
      if !between.exists(_.isInstanceOf[`\n`]) =>
    Decision(t, splits.map(_.withModification(Space)))
  case Decision(t@FormatToken(`lastRef`, _, _), splits) =>
    Decision(t, splits.map(_.withModification(Newline2x)))
})
<<< Looong
Seq(
  Split(modification, 0, policy = singleLine)
    .withIndent(indent, close, Left)
     .withOptimal(optimalTok),
  Split(Newline, 1 + nestedPenalty + lhsPenalty, policy = singleLine)
    .withIndent(indent, close, Left)
    .withOptimal(optimalTok),
  Split(modification, 2 + lhsPenalty, policy = oneArgOneLine, ignoreIf = singleArgument)
    .withIndent(StateColumn, close, Right)
    .withOptimal(optimalTok),
  Split(Newline,
    3 + nestedPenalty + lhsPenalty,
    policy = oneArgOneLine, ignoreIf = singleArgument)
    .withIndent(indent, close, Left)

)
>>>
Seq(
    Split(modification, 0, policy = singleLine)
      .withIndent(indent, close, Left)
      .withOptimal(optimalTok),
    Split(Newline, 1 + nestedPenalty + lhsPenalty, policy = singleLine)
      .withIndent(indent, close, Left)
      .withOptimal(optimalTok),
    Split(modification,
          2 + lhsPenalty,
          policy = oneArgOneLine,
          ignoreIf = singleArgument)
      .withIndent(StateColumn, close, Right)
      .withOptimal(optimalTok),
    Split(Newline,
          3 + nestedPenalty + lhsPenalty,
          policy = oneArgOneLine,
          ignoreIf = singleArgument).withIndent(indent, close, Left)
)
<<< continuation indent
Seq(
            // Either everything fits in one line or break on =>
            Split(Space, 0).withPolicy(SingleLineBlock(lastToken)),
            Split(Space, 1).withPolicy(Policy({
                  case Decision(t@FormatToken(`arrow`, _, _), s) =>
                    Decision(t, s.filter(_.modification.isNewline))
                },
                expire = lastToken.end))
              .withIndent(2, lastToken, Left) // case body indented by 2.
              .withIndent(2, arrow, Left) // cond body indented by 4.
        )
>>>
Seq(
    // Either everything fits in one line or break on =>
    Split(Space, 0).withPolicy(SingleLineBlock(lastToken)),
    Split(Space, 1)
      .withPolicy(Policy({
        case Decision(t@FormatToken(`arrow`, _, _), s) =>
          Decision(t, s.filter(_.modification.isNewline))
      }, expire = lastToken.end))
      .withIndent(2, lastToken, Left) // case body indented by 2.
      .withIndent(2, arrow, Left) // cond body indented by 4.
)
<<< breaking on ( is cheaper than [
val ret =
  new mutable.MapBuilder[TokenHash, Tree, Map[TokenHash, Tree]](Map[TokenHash, Tree]())
>>>
val ret = new mutable.MapBuilder[TokenHash, Tree, Map[TokenHash, Tree]](
    Map[TokenHash, Tree]())
<<< . is cheaper
{{{{
        Seq(
            Split(
                  // This split needs to have an optimalAt field.
                  Space,
                  0,
                  ignoreIf = !spaceCouldBeOk,
                  optimalAt = Some(expire)).withPolicy(SingleLineBlockAAAA(
                expire))
        )

}}}}
>>>
{
  {
    {
      {
        Seq(
            Split(
                  // This split needs to have an optimalAt field.
                  Space,
                  0,
                  ignoreIf = !spaceCouldBeOk,
                  optimalAt = Some(expire))
              .withPolicy(SingleLineBlockAAAA(expire))
        )
      }
    }
  }
}
<<< penalize newlines inside apply 1
val ret =
       new mutable.MapBuilder[TokenHash, Token, Map[TokenHash, Token]](Map
             .empty[TokenHash, Token])
>>>
val ret = new mutable.MapBuilder[TokenHash, Token, Map[TokenHash, Token]](
    Map.empty[TokenHash, Token])
<<< penalize newlines inside apply 2
{{
val result = new scala.collection.mutable.SetBuilder[Token, Set[Token]](Set.empty[Token])
}}
>>>
{
  {
    val result = new scala.collection.mutable.SetBuilder[Token, Set[Token]](
        Set.empty[Token])
  }
}
<<< property scalding
  writeRead(
    // Use list because Array has a shitty toString
    { (b: List[Byte], os) => os.writePosVarInt(b.size); os.writeBytes(b.toArray) },
    { is =>
      val bytes = new Array[Byte](is.readPosVarInt)
      is.readFully(bytes)
      bytes.toList
    })
>>>
writeRead(
          // Use list because Array has a shitty toString
          { (b: List[Byte], os) =>
            os.writePosVarInt(b.size); os.writeBytes(b.toArray)
          }, { is =>
            val bytes = new Array[Byte](is.readPosVarInt)
            is.readFully(bytes)
            bytes.toList
          })
