40 columns                              |
<<< has expression
s"${a.foo[Bar]}"
>>>
s"${a.foo[Bar]}"
<<< xml
<foobar>1</foobar>

>>>
<foobar>1</foobar>
<<< with leading whitespace
s"""${a.foo[Bar]}
    Nicely indented
"""
>>>
s"""${a.foo[Bar]}
    Nicely indented
"""
<<< two separate
{
  val line = s"=" * 4
  s"$line\n=> $t\n$line"
}
>>>
{
  val line = s"=" * 4
  s"$line\n=> $t\n$line"
}
<<< new inside expr
def shortInfo: String = s"created=${new Date()}"
>>>
def shortInfo: String =
  s"created=${new Date()}"
<<< example 1
s"cols:${e.  pos.start.  column}-${e.pos.end.column}"
>>>
s"cols:${e.pos.start.column}-${e.pos.end.column}"
<<< skip multiline interpolate with following token
s"""${a.foo[Bar]}
    Nicely indented
""".format(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
>>>
s"""${a.foo[Bar]}
    Nicely indented
""".format(
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
<<< multiline string with following token
"a" + """
    Nicely indented
""".format(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
>>>
"a" + """
    Nicely indented
""".format(
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
<<< don't break if no need
val msg =

  s"""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 |${mkString(deepestYet.splits)}
      |""".stripMargin
>>>
val msg =
  s"""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
     |${mkString(deepestYet.splits)}
     |""".stripMargin
<<< no align if no margin
val msg =
  s"""
 ${mkString(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)}
      """
>>>
val msg = s"""
 ${mkString(
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)}
      """
<<< break indentation
val msg =

  s"""AAAAAAA
      |${mkString(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbb)}
      |""".stripMargin
>>>
val msg =
  s"""AAAAAAA
     |${mkString(
         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
         bbb)}
     |""".stripMargin
<<< Align | margin 2
val msg =

  s"""UNABLE TO FORMAT,
      |${mkString(deepestYet.splits)}
      |""".stripMargin
>>>
val msg = s"""UNABLE TO FORMAT,
             |${mkString(deepestYet.splits)}
             |""".stripMargin
