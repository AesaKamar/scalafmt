40 columns                              |
<<< One argument per line
object Object {
  val x = function[a1234567, b1234567,
                   c1234567, d1234567]
  val y = 2 // indented correctly
}
>>>
object Object {
  val x = function[a1234567,
                   b1234567,
                   c1234567,
                   d1234567]
  val y = 2 // indented correctly
}
<<< Single line with newline at start
object a {
  function[aaaaaaaaaaaaaa, aaaaaaaaaaaaaa]()
}
>>>
object a {
  function[aaaaaaaaaaaaaa,
           aaaaaaaaaaaaaa]()
}
<<< One line one arg at 4 indent
object a {
  function[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]
}
>>>
object a {
  function[
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]
}
<<< Type args and args different policy
object Object {
  val x = function[a1234567, b1234567](a)
}
>>>
object Object {
  val x =
    function[a1234567, b1234567](a)
}
<<< val type apply formats too #117
val x:FooBarrrrrr[BaaaaaaaaaaaazBazzz[ String, Option[ List[Either[ Int, Option[String] ]]] ]]
>>>
val x: FooBarrrrrr[BaaaaaaaaaaaazBazzz[
        String,
        Option[List[Either[
            Int,
            Option[String]]]]]]
<<< SKIP var type apply formats too #117
var x:FooBarrrrrr[B[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]]
>>>
x
<<< insane type apply from u/refriedi via reddit
def myMethod[F[_]:Functor, G[_]:Applicative, A:DecodeJson:TypeTag:Meta, B:DecodeJson:TypeTag:Meta, C:Meta:TypeTag:UrlParameterEncode](gfa: G[F[A]], b: B)(f: (A,B) => C): Foo[C]
>>>
def myMethod[
    F[_]: Functor,
    G[_]: Applicative,
    A : DecodeJson : TypeTag : Meta,
    B : DecodeJson : TypeTag : Meta,
    C : Meta : TypeTag : UrlParameterEncode](
    gfa: G[F[A]], b: B)(
    f: (A, B) => C): Foo[C]
